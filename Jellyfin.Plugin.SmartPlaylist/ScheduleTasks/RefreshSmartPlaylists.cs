using Jellyfin.Data.Entities;
using Jellyfin.Data.Enums;
using Jellyfin.Plugin.SmartPlaylist.Infrastructure;
using Jellyfin.Plugin.SmartPlaylist.Interfaces;
using Jellyfin.Plugin.SmartPlaylist.Models.Dto;
using MediaBrowser.Controller;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Playlists;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.IO;
using MediaBrowser.Model.Playlists;
using MediaBrowser.Model.Tasks;
using System;
using Jellyfin.Data.Events;

namespace Jellyfin.Plugin.SmartPlaylist.ScheduleTasks;

public class RefreshSmartPlaylists : IScheduledTask, IConfigurableScheduledTask {
	private readonly IFileSystem _fileSystem;
	private readonly ILibraryManager _libraryManager;
	private readonly ILogger _logger;
	private readonly IPlaylistManager _playlistManager;
	private readonly ISmartPlaylistStore _plStore;
	private readonly IProviderManager _providerManager;
	private readonly IUserManager _userManager;

	public RefreshSmartPlaylists(IFileSystem fileSystem,
							   ILibraryManager libraryManager,
							   ILogger<RefreshSmartPlaylists> logger,
							   IPlaylistManager playlistManager,
							   IProviderManager providerManager,
							   IServerApplicationPaths serverApplicationPaths,
							   IUserManager userManager) {
		_fileSystem = fileSystem;
		_libraryManager = libraryManager;
		_logger = logger;
		_playlistManager = playlistManager;
		_providerManager = providerManager;
		_userManager = userManager;

		ISmartPlaylistFileSystem plFileSystem = new SmartPlaylistFileSystem(serverApplicationPaths);
		_plStore = new SmartPlaylistStore(plFileSystem, logger);
	}

	private string CreateNewPlaylist(SmartPlaylistDto dto, User user, IReadOnlyList<Guid> items) {
		var req = new PlaylistCreationRequest {
			Name = dto.Name,
			UserId = user.Id,
			ItemIdList = items,
		};

		var foo = _playlistManager.CreatePlaylist(req);

		return foo.Result.Id;
	}

	private IEnumerable<BaseItem> GetAllUserMedia(User user, BaseItemKind[] itemTypes) {
		var query = new InternalItemsQuery(user) {
			IncludeItemTypes = itemTypes,
			Recursive = true,
		};

		return _libraryManager.GetItemsResult(query).Items;
	}


	public bool IsHidden => false;

	public bool IsEnabled => true;

	public bool IsLogged => true;

	public string Key => nameof(RefreshSmartPlaylists);

	public string Name => "Refresh all SmartPlaylist";

	public string Description => "Refresh all SmartPlaylists Playlists";

	public string Category => "Smart Playlist 2 Playlist Harder";

	// TODO check for creation of schedule json file. Isn't created currently and won't execute until it is.
	public IEnumerable<TaskTriggerInfo> GetDefaultTriggers() {
		return new[] {
				new TaskTriggerInfo {
						IntervalTicks = TimeSpan.FromMinutes(30).Ticks,
						Type          = TaskTriggerInfo.TriggerInterval
				}
		};
	}

	public async Task ExecuteAsync(IProgress<double> progress, CancellationToken cancellationToken) {
		try {
			var dtos = await _plStore.GetAllSmartPlaylistAsync();

			for (var index = 0; index < dtos.Length; index++) {
				var dto = dtos[index];

				if (dto.IsReadonly) {
					continue;
				}

				var smartPlaylist = new Models.SmartPlaylist(dto);

				var user = _userManager.GetUserByName(smartPlaylist.User);
				progress.ReportPercentage(dtos.Length, index, 5);
				List<Playlist> p = new();

				try {
					var playlists = _playlistManager.GetPlaylists(user.Id);
					p.AddRange(playlists.Where(x => x.Id.ToString("N") == dto.Id));
				}
				catch (NullReferenceException ex) {
					_logger.LogError(ex,
									 "No user named {User} found, please fix playlist {PlaylistName}",
									 dto.User,
									 dto.Name);

					continue;
				}

				progress.ReportPercentage(dtos.Length, index, 20);


				var newItems = smartPlaylist.FilterPlaylistItems(GetAllUserMedia(user, smartPlaylist.SupportedItems),
																 _libraryManager,
																 user)
											.ToArray();

				var newItemIds = newItems.Select(x => x.Id).ToArray();

				progress.ReportPercentage(dtos.Length, index, 40);

				if ((dto.Id == null) || !p.Any()) {
					_logger.LogInformation("Playlist ID not set, creating new playlist");
					var plId = CreateNewPlaylist(dto, user, newItemIds);
					dto.Id = plId;
					await _plStore.SaveAsync(dto);

					continue;
				}

				progress.ReportPercentage(dtos.Length, index, 50);

				var query = new InternalItemsQuery(user) {
					IncludeItemTypes = smartPlaylist.SupportedItems.ToArray(),
					Recursive = true,
				};
				var playlist = p.First();
				var plItems = playlist.GetChildren(user, false, query).ToList();
				var toRemove = plItems.Select(x => x.Id.ToString()).ToList();
				playlist.Tagline = $"{dto.Name} Generated by {SmartPlaylistConsts.PLUGIN_NAME}";
				await RemoveFromPlaylist(playlist.Id.ToString(), toRemove);

				for (int i = 0; i < 10; i++) {
					progress.ReportPercentage(dtos.Length, index, 60 + i);
					//This is gross
					await Task.Delay(100, cancellationToken);
				}

				await _playlistManager.AddToPlaylistAsync(playlist.Id, newItemIds, user.Id);

				progress.ReportPercentage(dtos.Length, index, 100);
			}
		}
		catch (Exception ex) {
			_logger.LogError(ex, "Error processing playlists");
		}
	}

	// Real PlaylistManagers RemoveFromPlaylist needs an entry ID which seems to not work. Explore further and file a bug.
	public async Task RemoveFromPlaylist(string playlistId, IEnumerable<string> entryIds) {
		if (_libraryManager.GetItemById(playlistId) is not Playlist playlist) {
			throw new ArgumentException("No Playlist exists with the supplied Id");
		}

		var children = playlist.GetManageableItems().ToList();

		var idList = entryIds.ToList();
		var removals = children.Where(i => idList.Contains(i.Item1.ItemId.ToString())).ToArray();

		playlist.LinkedChildren = children.Except(removals)
										  .Select(i => i.Item1)
										  .ToArray();

		await playlist.UpdateToRepositoryAsync(ItemUpdateType.MetadataEdit, CancellationToken.None);
		QueueRefresh(playlist.Id);
	}

	public void QueueRefresh(Guid playlistId) {
		_providerManager.QueueRefresh(playlistId,
									  new(new DirectoryService(_fileSystem)) {
										  ForceSave = true
									  },
									  RefreshPriority.High);
	}
}
